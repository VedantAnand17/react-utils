#!/usr/bin/env node

/* Auxiliary script that helps to install and upgrade libraries
 * published to NPM. */
/* eslint-disable import/no-extraneous-dependencies, no-console  */

const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const commander = require('commander');

const COMMAND_DESCRIPTION = `\
Automates library installation and upgrades.

Installs the latest version of each library from the whitespace separated list
[libraries...]. After installing each library, it also installs into the current
package:
1.  All development dependencies of that library, with the versions specified by
    the library, and it saves them as dev dependencies of the current package.
2.  All production dependencies, common between the library and the current
    project, using the versions specified by the library. These dependencies
    and their versions are saved as prod dependencies of the current package.

If no [libraries...] are specified, it installs "@dr.pogodin/react-utils" by
default.

"--just-fix-deps" option allows to skip the actual libirary installations,
it just checks the libirary versions currently installed, and installs their
development, and production dependencies, into the current package, the way
described above.`;

let libs;

/* Command-line config. */
commander
  .version('0.1.1')
  .name('react-utils-setup')
  .arguments('[libraries...]')
  .action((libraries) => {
    libs = libraries || ['@dr.pogodin/react-utils'];
  })
  .description(COMMAND_DESCRIPTION)
  .option(
    '--just-fix-deps',
    'Skips library installation, just fixes dependencies.',
    false,
  )
  .parse(process.argv);

/**
 * Generates a string containing name and version of the package to be
 * installed.
 * @param {Array} entry Array with package name as the first element, and
 *  corresponding version or URI given in a `package.json`.
 * @return {String} Package name and version as a string that can be passed
 *  into NPM's install command.
 */
function generateTargetPackage(entry) {
  if (entry[1].match(/^(git\+)?(file|https)?:\/\//)) return entry[1];
  if (entry[1].match(/^[\^~]/)) return `${entry[0]}@${entry[1].slice(1)}`;
  return `${entry[0]}@${entry[1]}`;
}

/**
 * Adopts dev dependencies of the `donor` package into the `host` one.
 * @param {Object} donorData Data from donor's `package.json`.
 * @param {Object} hostData Data from host's `package.json`.
 */
function adoptDevDependencies(donorData) {
  let deps = Object.entries(donorData.devDependencies || {});
  deps = deps.map(generateTargetPackage);
  spawnSync('npm', ['install', '--save-dev'].concat(deps), {
    stdio: 'inherit',
  });
}

/**
 * Locates and loads `package.json` of the host package (assumed to be inside
 * the current working directory).
 * @return {Object} Data from `package.json` parsed into JSON.
 */
function getHostPackageJson() {
  const url = path.resolve(process.cwd(), 'package.json');
  return JSON.parse(fs.readFileSync(url));
}

/**
 * Locates and loads `package.json` file of the specified package.
 * @param {String} package Package name.
 * @return {Object} Data from `package.json` parsed into JSON.
 */
function getPackageJson(packageName = '@dr.pogodin/react-utils') {
  let url = packageName === '@dr.pogodin/react-utils' ? '..' : packageName;
  url = path.dirname(require.resolve(url));
  for (;;) {
    const files = fs.readdirSync(url);
    if (files.includes('package.json')) {
      url = path.resolve(url, 'package.json');
      break;
    }
    const up = path.resolve(url, '..');
    if (url === up) throw new Error(`Cannot find the package ${packageName}`);
    url = up;
  }
  return JSON.parse(fs.readFileSync(url));
}

/**
 * Installs specified library.
 * @param {String} library Library name.
 */
function install(library) {
  let name = library;
  if (name.indexOf('@') <= 0) name += '@latest';
  spawnSync('npm', ['install', '--save', name], { stdio: 'inherit' });
}

/**
 * Updates prod dependencies of `host` package that are also prod dependencies
 * of `donor` to the same versions specified in the donor's `package.json`.
 * @param {Object} donorData Data from donor's `package.json`.
 * @param {Object} hostData Data from host's `package.json`.
 */
function updateProdDependencies(donorData, hostData) {
  let deps = Object.entries(donorData.dependencies || {});
  const hostDeps = hostData.dependencies || {};
  deps = deps.filter((x) => hostDeps[x[0]]);
  deps = deps.map(generateTargetPackage);
  spawnSync('npm', ['install', '--save'].concat(deps), { stdio: 'inherit' });
}

/* Entry point. */

const hostData = getHostPackageJson();
libs.forEach((library) => {
  if (!commander.justFixDeps) install(library);
  const libData = getPackageJson(library);
  adoptDevDependencies(libData, hostData);
  updateProdDependencies(libData, hostData);
});
spawnSync('npm', ['install'], { stdio: 'inherit' });
